package org.example.chapter04;

public class Explain {
    /*
        객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.

        // 연관관계 주인
        테이블 : 참조 값 1개 (외래 키)
        객체 : 참조 값 2개
        -> 객체는 테이블에 맞춰 참조 값 1개를 정해야한다!(혼란방지,성능)
*****   -> 외래 키의 위치를 기준으로 정해라 !! *****
*****   -> Many가 되는 쪽이 연관관계의 주인으로 정해라!(성능이 좋다) *****
        -> mapped 하는 쪽은 어차피 DB에 반영되지 않음.
        실무 : 양쪽에 전부 지정해줘야 한다.

        Why -> 1. 쓰기 지연 저장소(1차캐시)에 보관되기 때문에, Collection에 값이 들어가있지 않음
               2. flush()후 clear()하면 가능하긴 하지만, 이때 Select문이 나가기때문에 비효율적임
               3. TestCase 작성시, 순수 자바코드로 작성하기때문에 1번항목에서 Null발생

        -> 양쪽에 넣는거 불편하니, 연관관계 편의 메서드를 만들어 사용하자 !!
        이때, 이름은 자바에서 관례적으로 사용하는 의미 + 중요한 작업을 하고있다는걸 알리는 의미로
        change처럼, 특정한 이름으로 지정해 사용, 이때 어느쪽에 만들어 사용하던 상관없음
            public void changeTeam(Team04cv1 team) {
                this.team = team;
                team.getMembers().add(this);
            }

            public void addMember(Member04cv1 member04cv1){
                member04cv1.setTeam(this);
                members.add(member04cv1);
            }

            ※ 양방향 연관관계 매핑시 주의사항※
            toString() 함수를 통해 서로 순환참조가 일어날 수 있음
            특히 1. Lombok, 2. JSON 생성 라이브러리 조심해야됨 !!
            -> lombok toString 쓰지마라
            -> 컨트롤러에서 엔티티로 반환하지 마라 !!
                -> 엔티티가 바뀌면 다 바뀌어야 됨 -> DTO로 사용 !

            결론 : 양방향 매핑을 사용하지 말고, 단방향 매핑으로 설계를 끝내라!
            -> 초기에는 Many to one, One ot One에서 단방향으로만 설계를 끝내라.
            Why? -> 객체 입장에서 양방향 맵핑은 이득이 많지 않기 때문에
            그럼 언제 양방향으로 설계?
            -> 중간에 필요할때 설계함, 테이블에 영향을 주지 않기 때문에 가능함 !

            양방향 매핑(연관관계)는 편의 + JPQL을 실무에서 짜다보니.. 양쪽으로 조회해야할 일이 생김!```
     */
}
